% fehlerzähler mit test korpus
% test korpus wird in tasten umgewandelt und mit dem T9-Erkenner wieder
% zurück gewandelt
% Ausgabe wird mit ursprünglichen Text verglichen und unterschiede erkannt
% Fehlerrate = Fehler / test_korpus_länge

clear all;
close all;
clc;

global keySequence
global newKey
global symbolTree
global dictionary
global previousIndices
global nodeIndices
global probTree
global cap
global nGram

% Initialise tree structure
symbolTree = tree({'_', 1,1});

% set cap for appendToTree
cap = 0;

% Initialise arrays
previousIndices = 1;
nodeIndices = {0 0}';
keySequence = [];
newKey = [];
nGram = 3;

% define language
language = 'german';

%load corpus clean
load([language,'TestClean.mat']);

%load prob Tree
load([language,'ProbabilityTree.mat']);

% Test sequence
% test_sequence = corpus(1:300);
test_sequence = 'hallo_ich_komme_aus._steinfurt_und_studiere_elektro';

key_sequence = test_sequence;
test_sequence = ['' , test_sequence];

for j = 1 : nKeys
    
key_sequence(ismember(test_sequence, dictionary(keySet{j}))) = keySet{j};

end

error_rate = 0;
inco_sign = 0;
length_test = length(test_sequence);

for j = 1 : 1 : length(key_sequence)
    
    if (key_sequence(j) ~= '1')
    newKey = num2str(key_sequence(j)); 
    keySequence = [keySequence, newKey];
    [symbolTree,index] = appendToTree(newKey, symbolTree, probTree, nGram);   
    
    else
    prov_sequence = symbolTree.Node{index(length(index)),1}{1, 1};
    prov_sequence = [prov_sequence , '.'];
    
     % test sequence abschneiden
    key_sequence = key_sequence(j:end);
    clearvars symbolTree;
    
     for j =  1 : length(prov_sequence)
      if(prov_sequence(j) ~= test_sequence(j))
           inco_sign = inco_sign + 1;
      end
     end
     
    end
end
    
    error_rate = inco_sign / length_test
    
    
    
    
  